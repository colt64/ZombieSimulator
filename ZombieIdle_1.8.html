<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zombie Simulator</title>
    <style>
        /* General body styling */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a1a;
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }




        /* Main container for the game */
        .game-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            padding: 20px;
            background-color: #2c2c2c;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            width: 100%;
            max-width: 950px;
            box-sizing: border-box;
            position: relative;
        }




        /* Canvas styling */
        canvas {
            background-color: #1a1a1a;
            border-radius: 8px;
            border: 2px solid #555;
            width: 100%;
            height: auto;
        }




        /* Status counters */
        .status-counters {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around;
            width: 100%;
            padding: 10px 0;
            background-color: #383838;
            border-radius: 8px;
            font-weight: bold;
        }




        .status-counters div {
            display: flex;
            align-items: center;
            gap: 5px;
            margin: 5px;
        }




        .status-counters span {
            font-size: 1.2rem;
            color: white;
        }




        /* Controls panel with grid layout */
        .controls {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            padding: 10px;
            background-color: #383838;
            border-radius: 8px;
        }




        /* Grouping panels for controls */
        .control-panel {
            background-color: #444;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Hide overflow for smooth transition */
        }
        
        .control-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            background-color: #555;
            cursor: pointer;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: bold;
            color: #fff;
            transition: background-color 0.3s ease;
        }
        
        .control-panel-header:hover {
            background-color: #666;
        }
        
        .control-panel-header .toggle-icon {
            font-size: 1.5rem;
            transition: transform 0.3s ease;
        }
        
        .control-panel.collapsed .toggle-icon {
            transform: rotate(-90deg);
        }




        .control-panel .input-row {
            padding: 15px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            max-height: 500px; /* A value larger than the max expected height */
            transition: max-height 0.5s ease-out, padding 0.5s ease-out;
            overflow: hidden;
        }
        
        .control-panel.collapsed .input-row {
            max-height: 0;
            padding-top: 0;
            padding-bottom: 0;
        }




        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            width: 100%;
            max-width: 150px;
        }




        .control-group label {
            font-size: 0.9rem;
            color: #bbb;
            text-align: center;
        }




        /* Input styling */
        .control-group input[type="number"], .control-group input[type="range"] {
            width: 100%;
            max-width: 150px;
            padding: 8px;
            border: none;
            border-radius: 6px;
            background-color: #555;
            color: #fff;
            text-align: center;
        }
        
        /* Specific styling for number inputs */
        .control-group input[type="number"] {
            -moz-appearance: textfield; /* Hide number arrows in Firefox */
        }




        .control-group input[type="number"]::-webkit-inner-spin-button,
        .control-group input[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }




        /* Range slider styling */
        input[type="range"] {
            -webkit-appearance: none;
            background: transparent;
        }




        input[type="range"]::-webkit-slider-runnable-track {
            height: 8px;
            background: #555;
            border-radius: 4px;
        }




        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            background: #4CAF50;
            border-radius: 50%;
            margin-top: -4px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            cursor: pointer;
        }




        /* Checkbox styling */
        .checkbox-group {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 0.9rem;
            color: #bbb;
            width: 100%;
        }




        .checkbox-group input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
            border-radius: 4px;
            accent-color: #4CAF50;
        }




        /* Buttons styling */
        .buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 10px;
        }




        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }




        button#startBtn {
            background-color: #4CAF50; /* Green */
            color: white;
        }




        button#resetBtn {
            background-color: #f44336; /* Red */
            color: white;
        }
        
        button#toggleModeBtn {
            background-color: #1e88e5; /* Blue */
            color: white;
        }




        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.3);
        }




        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }




        /* Custom message box styling */
        .message-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #333;
            color: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.5);
            text-align: center;
            z-index: 1001;
            display: none;
            flex-direction: column;
            gap: 20px;
            max-width: 90%;
            animation: fadeIn 0.5s ease-out;
        }




        .message-box button {
            background-color: #f44336;
            color: white;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }




        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            display: none;
        }
        
        .mode-display {
            text-align: center;
            font-size: 1.2rem;
            font-weight: bold;
            color: #1e88e5;
            margin-bottom: 10px;
        }




        /* Responsive design for small screens */
        @media (max-width: 768px) {
            .game-container {
                padding: 10px;
                gap: 10px;
            }
            .controls {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            .control-panel .input-row {
                flex-direction: column;
                align-items: center;
            }
            .control-group {
                max-width: none;
                width: 100%;
            }
            .buttons {
                flex-direction: column;
            }
            button {
                width: 100%;
            }
            .status-counters {
                flex-direction: column;
                align-items: center;
                gap: 10px;
            }
        }
    </style>
</head>
<body>




    <div class="game-container">
        <h1>Zombie Simulator</h1>
        <div class="status-counters">
            <div>People: <span id="personCountDisplay"></span></div>
            <div>Zombies: <span id="zombieCountDisplay"></span></div>
            <div>Rage Zombies: <span id="rageZombieCountDisplay"></span></div>
            <div>Police: <span id="policeCountDisplay"></span></div>
            <div>Supplies Collected: <span id="suppliesCollectedDisplay"></span></div>
        </div>
        <div id="modeDisplay" class="mode-display">Mode: Sim</div>
        <canvas id="gameCanvas"></canvas>




        <div class="controls">
            <!-- Population Controls -->
            <div class="control-panel">
                <div class="control-panel-header">
                    <span>Population & Initial Counts</span>
                    <span class="toggle-icon">&#9660;</span>
                </div>
                <div class="input-row">
                    <div class="control-group">
                        <label for="personCount">Initial People</label>
                        <input type="number" id="personCount" value="100" min="0">
                    </div>
                    <div class="control-group">
                        <label for="zombieCount">Initial Zombies</label>
                        <input type="number" id="zombieCount" value="5" min="0">
                    </div>
                    <div class="control-group">
                        <label for="rageZombieCount">Initial Rage Zombies</label>
                        <input type="number" id="rageZombieCount" value="1" min="0">
                    </div>
                    <div class="control-group">
                        <label for="policeCount">Initial Police</label>
                        <input type="number" id="policeCount" value="2" min="0">
                    </div>
                </div>
            </div>




            <!-- Idle Game Emitters - New Panel -->
            <div class="control-panel">
                <div class="control-panel-header">
                    <span>Idle Game Emitters</span>
                    <span class="toggle-icon">&#9660;</span>
                </div>
                <div class="input-row">
                    <div class="control-group">
                        <label for="humanSpawnRate">Human Spawn Rate: <span id="humanSpawnRateValue">2000</span>ms</label>
                        <input type="range" id="humanSpawnRate" min="100" max="10000" step="100" value="2000">
                    </div>
                    <div class="control-group">
                        <label for="zombieSpawnRate">Zombie Spawn Rate: <span id="zombieSpawnRateValue">2000</span>ms</label>
                        <input type="range" id="zombieSpawnRate" min="100" max="10000" step="100" value="2000">
                    </div>
                    <div class="control-group">
                        <label for="rageZombieSpawnRate">Rage Zombie Spawn Rate: <span id="rageZombieSpawnRateValue">5000</span>ms</label>
                        <input type="range" id="rageZombieSpawnRate" min="100" max="10000" step="100" value="5000">
                    </div>
                    <div class="control-group">
                        <label for="policeSpawnRate">Police Spawn Rate: <span id="policeSpawnRateValue">5000</span>ms</label>
                        <input type="range" id="policeSpawnRate" min="100" max="10000" step="100" value="5000">
                    </div>
                </div>
            </div>




            <!-- Simulation & Map Controls -->
            <div class="control-panel">
                <div class="control-panel-header">
                    <span>Simulation & Map Settings</span>
                    <span class="toggle-icon">&#9660;</span>
                </div>
                <div class="input-row">
                    <div class="control-group">
                        <label for="mapSize">Map Size: <span id="mapSizeValue">800</span>px</label>
                        <input type="range" id="mapSize" min="200" max="1500" step="50" value="800">
                    </div>
                    <div class="control-group">
                        <label for="buildingDensity">Building Density: <span id="buildingDensityValue">50</span>%</label>
                        <input type="range" id="buildingDensity" min="0" max="100" value="50">
                    </div>
                    <div class="control-group">
                        <label for="supplySpawnRate">Supply Spawn Rate: <span id="supplySpawnRateValue">2000</span>ms</label>
                        <input type="range" id="supplySpawnRate" min="100" max="10000" step="100" value="2000">
                    </div>
                </div>
            </div>




            <!-- Flocking & Behavior Controls -->
            <div class="control-panel">
                <div class="control-panel-header">
                    <span>Behavioral Settings</span>
                    <span class="toggle-icon">&#9660;</span>
                </div>
                <div class="input-row">
                    <div class="control-group">
                        <label for="cohesionRadius">Cohesion Radius</label>
                        <input type="range" id="cohesionRadius" min="0" max="200" value="75">
                    </div>
                    <div class="control-group">
                        <label for="cohesionInstinct">Cohesion Instinct</label>
                        <input type="range" id="cohesionInstinct" min="0" max="1" step="0.05" value="0.5">
                    </div>
                    <div class="control-group">
                        <label for="separationRadius">Separation Radius</label>
                        <input type="range" id="separationRadius" min="0" max="50" value="15">
                    </div>
                    <div class="control-group">
                        <label for="separationInstinct">Separation Instinct</label>
                        <input type="range" id="separationInstinct" min="0" max="1" step="0.05" value="0.8">
                    </div>
                    <div class="control-group">
                        <label for="alignmentRadius">Alignment Radius</label>
                        <input type="range" id="alignmentRadius" min="0" max="200" value="75">
                    </div>
                    <div class="control-group">
                        <label for="alignmentInstinct">Alignment Instinct</label>
                        <input type="range" id="alignmentInstinct" min="0" max="1" step="0.05" value="0.5">
                    </div>
                    <div class="control-group">
                        <label for="policeFireRate">Police Fire Rate</label>
                        <input type="range" id="policeFireRate" min="10" max="120" value="30">
                    </div>
                    <div class="control-group">
                        <label for="zombieDecayDuration">Zombie Decay: <span id="zombieDecayDurationValue">3000</span>ms</label>
                        <input type="range" id="zombieDecayDuration" min="100" max="10000" step="100" value="3000">
                    </div>
                </div>
            </div>




            <!-- Toggles Panel -->
            <div class="control-panel">
                <div class="control-panel-header">
                    <span>Toggles</span>
                    <span class="toggle-icon">&#9660;</span>
                </div>
                <div class="input-row">
                    <div class="checkbox-group">
                        <input type="checkbox" id="peopleFlockingToggle" checked>
                        <label for="peopleFlockingToggle">People Flocking</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="zombieFlockingToggle" checked>
                        <label for="zombieFlockingToggle">Zombie Flocking</label>
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="policeImmunityToggle" checked>
                        <label for="policeImmunityToggle">Police Immune</label>
                    </div>
                </div>
            </div>
        </div>




        <div class="buttons">
            <button id="startBtn">Start Simulation</button>
            <button id="resetBtn">Reset</button>
            <button id="toggleModeBtn">Toggle Mode</button>
        </div>
    </div>
    
    <!-- Custom message box -->
    <div id="overlay" class="overlay"></div>
    <div id="messageBox" class="message-box">
        <p id="messageText"></p>
        <button onclick="closeMessage()">OK</button>
    </div>




    <script>
        window.onload = function() {
            // --- CONSTANTS AND VARIABLES ---
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const startBtn = document.getElementById('startBtn');
            const resetBtn = document.getElementById('resetBtn');
            const toggleModeBtn = document.getElementById('toggleModeBtn');
            const modeDisplay = document.getElementById('modeDisplay');
            const zombieCountInput = document.getElementById('zombieCount');
            const rageZombieCountInput = document.getElementById('rageZombieCount');
            const personCountInput = document.getElementById('personCount');
            const policeCountInput = document.getElementById('policeCount');
            const personCountDisplay = document.getElementById('personCountDisplay');
            const zombieCountDisplay = document.getElementById('zombieCountDisplay');
            const rageZombieCountDisplay = document.getElementById('rageZombieCountDisplay');
            const policeCountDisplay = document.getElementById('policeCountDisplay');
            const suppliesCollectedDisplay = document.getElementById('suppliesCollectedDisplay');
            const cohesionRadiusInput = document.getElementById('cohesionRadius');
            const cohesionInstinctInput = document.getElementById('cohesionInstinct');
            const separationRadiusInput = document.getElementById('separationRadius');
            const separationInstinctInput = document.getElementById('separationInstinct');
            const alignmentRadiusInput = document.getElementById('alignmentRadius');
            const alignmentInstinctInput = document.getElementById('alignmentInstinct');
            const policeFireRateInput = document.getElementById('policeFireRate');
            const policeImmunityToggle = document.getElementById('policeImmunityToggle');
            const peopleFlockingToggle = document.getElementById('peopleFlockingToggle');
            const zombieFlockingToggle = document.getElementById('zombieFlockingToggle');
            const mapSizeInput = document.getElementById('mapSize'); 
            const mapSizeValueDisplay = document.getElementById('mapSizeValue');
            const buildingDensityInput = document.getElementById('buildingDensity'); 
            const buildingDensityValueDisplay = document.getElementById('buildingDensityValue'); 
            const humanSpawnRateInput = document.getElementById('humanSpawnRate');
            const humanSpawnRateValueDisplay = document.getElementById('humanSpawnRateValue');
            const zombieSpawnRateInput = document.getElementById('zombieSpawnRate');
            const zombieSpawnRateValueDisplay = document.getElementById('zombieSpawnRateValue');
            const rageZombieSpawnRateInput = document.getElementById('rageZombieSpawnRate');
            const rageZombieSpawnRateValueDisplay = document.getElementById('rageZombieSpawnRateValue');
            const policeSpawnRateInput = document.getElementById('policeSpawnRate');
            const policeSpawnRateValueDisplay = document.getElementById('policeSpawnRateValue');
            const zombieDecayDurationInput = document.getElementById('zombieDecayDuration');
            const zombieDecayDurationValueDisplay = document.getElementById('zombieDecayDurationValue');
            const supplySpawnRateInput = document.getElementById('supplySpawnRate');
            const supplySpawnRateValueDisplay = document.getElementById('supplySpawnRateValue');
            const messageBox = document.getElementById('messageBox');
            const messageText = document.getElementById('messageText');
            const overlay = document.getElementById('overlay');
            
            // Get all collapsible headers
            const collapsibleHeaders = document.querySelectorAll('.control-panel-header');




            let entities = [];
            let buildings = [];
            let supplies = [];
            let animationFrameId = null;
            let isRunning = false;
            let particles = [];
            let isIdleMode = true; // Default to Idle Mode
            
            // Emitter-specific state
            let humanEmitter = null;
            let zombieEmitter = null;
            let rageZombieEmitter = null; 
            let policeEmitter = null;
            let humanSpawnTimer = 0;
            let zombieSpawnTimer = 0;
            let rageZombieSpawnTimer = 0;
            let policeSpawnTimer = 0;
            let supplySpawnTimer = 0;
            let suppliesCollectedCount = 0;




            // Simulation parameters from sliders
            let cohesionRadius = parseFloat(cohesionRadiusInput.value);
            let cohesionInstinct = parseFloat(cohesionInstinctInput.value);
            let separationRadius = parseFloat(separationRadiusInput.value);
            let separationInstinct = parseFloat(separationInstinctInput.value);
            let alignmentRadius = parseFloat(alignmentRadiusInput.value);
            let alignmentInstinct = parseFloat(alignmentInstinctInput.value);
            let policeFireRate = parseFloat(policeFireRateInput.value);
            let policeImmunityEnabled = policeImmunityToggle.checked;
            let peopleFlockingEnabled = peopleFlockingToggle.checked;
            let zombieFlockingEnabled = zombieFlockingToggle.checked;
            let currentMapSize = parseFloat(mapSizeInput.value);
            let buildingDensity = parseFloat(buildingDensityInput.value); 
            let humanSpawnRate = parseFloat(humanSpawnRateInput.value);
            let zombieSpawnRate = parseFloat(zombieSpawnRateInput.value);
            let rageZombieSpawnRate = parseFloat(rageZombieSpawnRateInput.value);
            let policeSpawnRate = parseFloat(policeSpawnRateInput.value);
            let zombieDecayDuration = parseFloat(zombieDecayDurationInput.value);
            let supplySpawnRate = parseFloat(supplySpawnRateInput.value);








            // --- ENTITY CLASSES ---
            /**
             * Base class for all moving entities (people and zombies).
             */
            class Entity {
                constructor(x, y, size, speed, color) {
                    this.x = x;
                    this.y = y;
                    this.size = size;
                    this.speed = speed;
                    this.dx = (Math.random() - 0.5) * speed;
                    this.dy = (Math.random() - 0.5) * speed;
                    this.color = color;
                }




                /**
                 * Draws the entity on the canvas.
                 */
                draw() {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                }




                /**
                 * Moves the entity, checking for wall collisions and implementing pathing.
                 */
                move() {
                    // Check for building collisions with a "look ahead"
                    let willCollide = false;
                    for (const building of buildings) {
                        if (this.checkBuildingCollision(building, this.x + this.dx, this.y + this.dy)) {
                            willCollide = true;
                            break;
                        }
                    }




                    if (willCollide) {
                        // Find a new, clear path by trying different angles
                        let currentAngle = Math.atan2(this.dy, this.dx);
                        const anglesToTry = [
                            currentAngle + Math.PI / 2,
                            currentAngle - Math.PI / 2,
                            currentAngle + Math.PI
                        ];
                        
                        let newDirectionFound = false;
                        for (const angle of anglesToTry) {
                            const testDx = Math.cos(angle) * this.speed;
                            const testDy = Math.sin(angle) * this.speed;
                            
                            let testCollision = false;
                            for (const building of buildings) {
                                if (this.checkBuildingCollision(building, this.x + testDx, this.y + testDy)) {
                                    testCollision = true;
                                    break;
                                }
                            }
                            
                            if (!testCollision) {
                                this.dx = testDx;
                                this.dy = testDy;
                                newDirectionFound = true;
                                break;
                            }
                        }




                        if (!newDirectionFound) {
                            this.dx = (Math.random() - 0.5) * this.speed;
                            this.dy = (Math.random() - 0.5) * this.speed;
                        }
                    }




                    this.x += this.dx;
                    this.y += this.dy;




                    // Clamp position to prevent entities from leaving the canvas based on currentMapSize
                    if (this.x - this.size < 0) {
                        this.x = this.size;
                        this.dx = Math.abs(this.dx);
                    } else if (this.x + this.size > currentMapSize) {
                        this.x = currentMapSize - this.size;
                        this.dx = -Math.abs(this.dx);
                    }




                    if (this.y - this.size < 0) {
                        this.y = this.size;
                        this.dy = Math.abs(this.dy);
                    } else if (this.y + this.size > currentMapSize) {
                        this.y = currentMapSize - this.size;
                        this.dy = -Math.abs(this.dy);
                    }
                }




                /**
                 * Checks for collision with a building.
                 */
                checkBuildingCollision(building, x, y) {
                    const rectX = building.x;
                    const rectY = building.y;
                    const rectW = building.width;
                    const rectH = building.height;
                    const circleX = x;
                    const circleY = y;
                    const circleR = this.size;




                    const closestX = Math.max(rectX, Math.min(circleX, rectX + rectW));
                    const closestY = Math.max(rectY, Math.min(circleY, rectY + rectH));




                    const distanceX = circleX - closestX;
                    const distanceY = circleY - closestY;
                    const distanceSquared = (distanceX * distanceX) + (distanceY * distanceY);




                    return distanceSquared < (circleR * circleR);
                }
            }




            /**
             * Represents an uninfected person.
             */
            class Person extends Entity {
                constructor(x, y) {
                    super(x, y, 4, 1.5, '#cccccc');
                    this.type = 'person';
                    this.fleeSpeed = 1.5;
                    this.wanderSpeed = 0.5;
                    this.wanderTimer = 0;
                    this.baseWanderDuration = 120; // Base duration for wandering
                    this.state = 'wander'; // #supplylogic 'wander', 'seeking_supply', 'returning_to_base'
                    this.targetSupply = null; // #supplylogic
                    this.targetBase = null;
                    this.visionRange = 150;
                    this.hasSupply = false; // #supplylogic
                }
                
                /**
                 * Draws the person, changing color if they have a supply.
                 */
                draw() {
                    if (isIdleMode && this.hasSupply) { // #supplylogic
                        ctx.fillStyle = '#ffff00'; // #supplylogic Yellow when carrying a supply in Idle Mode
                    } else {
                        ctx.fillStyle = '#cccccc'; // Default color
                    }
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                }




                /**
                 * Person's movement logic: uses a state machine.
                 */
                move(zombies, allPeople, supplies, humanEmitter) {
                    const allZombies = zombies.filter(z => z.type === 'zombie' || z.type === 'rageZombie');
                    const nearestZombie = this.findNearest(allZombies);
                    
                    let movementVectorX = 0;
                    let movementVectorY = 0;
                    
                    // Fleeing logic always takes priority
                    if (nearestZombie && this.distanceTo(nearestZombie) < 100) {
                        this.state = 'fleeing';
                        const angle = Math.atan2(this.y - nearestZombie.y, this.x - nearestZombie.x);
                        movementVectorX = Math.cos(angle) * this.fleeSpeed;
                        movementVectorY = Math.sin(angle) * this.fleeSpeed;
                        this.speed = this.fleeSpeed;
                    } else {
                        // FIX: If we're not fleeing, and we were just fleeing, reset the state.
                        if (this.state === 'fleeing') {
                            this.state = 'wander';
                            this.wanderTimer = 0;
                        }
                        
                        // State Machine
                        switch (this.state) {
                            case 'wander':
                                // Look for supplies, only in Idle Mode
                                if (isIdleMode) {
                                    const visibleSupplies = supplies.filter(supply => this.hasLineOfSight(supply)); // #supplylogic
                                    if (visibleSupplies.length > 0) { // #supplylogic
                                        this.targetSupply = visibleSupplies[0]; // #supplylogic
                                        this.state = 'seeking_supply'; // #supplylogic
                                    }
                                }
                                
                                // **NEW LOGIC: "Safety in Numbers" for wandering**
                                // Count nearby people to determine wandering duration
                                let nearbyPeopleCount = 0;
                                for (const otherPerson of allPeople) {
                                    if (otherPerson === this) continue;
                                    const dist = this.distanceTo(otherPerson);
                                    if (dist < 50) { // Check within a 50px radius
                                        nearbyPeopleCount++;
                                    }
                                }
                                
                                // Increase wander duration based on group size, up to a cap
                                const groupBonus = Math.min(nearbyPeopleCount, 5) * 60; // Max bonus for 5+ people
                                const newWanderDuration = this.baseWanderDuration + groupBonus;
                                
                                // Random wandering logic
                                this.speed = this.wanderSpeed;
                                this.wanderTimer++;
                                if (this.wanderTimer > newWanderDuration) {
                                    this.dx = (Math.random() - 0.5) * this.wanderSpeed * 2;
                                    this.dy = (Math.random() - 0.5) * this.wanderSpeed * 2;
                                    this.wanderTimer = 0;
                                }
                                movementVectorX = this.dx;
                                movementVectorY = this.dy;
                                break;
                            
                            case 'seeking_supply': // #supplylogic
                                if (!this.targetSupply) { // #supplylogic
                                    this.state = 'wander'; // #supplylogic
                                    break;
                                }
                                
                                this.speed = 1.0;
                                const angleToSupply = Math.atan2(this.targetSupply.y - this.y, this.targetSupply.x - this.x); // #supplylogic
                                movementVectorX = Math.cos(angleToSupply) * this.speed; // #supplylogic
                                movementVectorY = Math.sin(angleToSupply) * this.speed; // #supplylogic




                                // Collision avoidance for seeking supplies
                                if (this.isPathBlocked(this.targetSupply)) {
                                    this.dx = (Math.random() - 0.5) * this.speed * 2;
                                    this.dy = (Math.random() - 0.5) * this.speed * 2;
                                    movementVectorX = this.dx;
                                    movementVectorY = this.dy;
                                }
                                break;




                            case 'returning_to_base': // #supplylogic
                                if (!humanEmitter) { // #supplylogic
                                    this.state = 'wander'; // #supplylogic Go back to wandering if no base exists
                                    break;
                                }
                                
                                this.speed = 1.0;
                                const angleToBase = Math.atan2(humanEmitter.y + humanEmitter.height / 2 - this.y, humanEmitter.x + humanEmitter.width / 2 - this.x); // #supplylogic
                                movementVectorX = Math.cos(angleToBase) * this.speed; // #supplylogic
                                movementVectorY = Math.sin(angleToBase) * this.speed; // #supplylogic
                                break;
                        }
                    }




                    // Flocking logic
                    if (peopleFlockingEnabled) {
                        let separationVectorX = 0;
                        let separationVectorY = 0;
                        for (const otherPerson of allPeople) {
                            if (otherPerson === this) continue;
                            const dist = this.distanceTo(otherPerson);
                            if (dist < separationRadius && dist > 0) {
                                const angle = Math.atan2(this.y - otherPerson.y, this.x - otherPerson.x);
                                const force = (separationRadius - dist) / separationRadius;
                                separationVectorX += Math.cos(angle) * force;
                                separationVectorY += Math.sin(angle) * force;
                            }
                        }




                        const separationMagnitude = Math.sqrt(separationVectorX * separationVectorX + separationVectorY * separationVectorY);
                        if (separationMagnitude > 0) {
                            separationVectorX /= separationMagnitude;
                            separationVectorY /= separationMagnitude;
                            
                            this.dx = movementVectorX * (1 - separationInstinct) + separationVectorX * this.speed * separationInstinct;
                            this.dy = movementVectorY * (1 - separationInstinct) + separationVectorY * this.speed * separationInstinct;
                            
                            const finalMagnitude = Math.sqrt(this.dx * this.dx + this.dy * this.dy);
                            if (finalMagnitude > this.speed) {
                                this.dx = (this.dx / finalMagnitude) * this.speed;
                                this.dy = (this.dy / finalMagnitude) * this.speed;
                            }
                        } else {
                            this.dx = movementVectorX;
                            this.dy = movementVectorY;
                        }
                    } else {
                        this.dx = movementVectorX;
                        this.dy = movementVectorY;
                    }
                    
                    super.move();
                }




                isPathBlocked(target) {
                    const dx = target.x - this.x;
                    const dy = target.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const step = 5;
                    const steps = Math.floor(distance / step);
                    const stepX = dx / steps;
                    const stepY = dy / steps;




                    for (const building of buildings) {
                        for (let i = 0; i < steps; i++) {
                            const checkX = this.x + stepX * i;
                            const checkY = this.y + stepY * i;
                            const distToCenter = Math.sqrt(
                                Math.pow(checkX - (building.x + building.width / 2), 2) +
                                Math.pow(checkY - (building.y + building.height / 2), 2)
                            );
                            const buildingRadius = Math.sqrt(building.width * building.width + building.height * building.height) / 2;
                            if (distToCenter < buildingRadius + this.size) {
                                return true;
                            }
                        }
                    }
                    return false;
                }




                /**
                 * Finds the nearest entity of a given type.
                 */
                findNearest(others) {
                    let nearest = null;
                    let minDistance = 200;
                    for (const other of others) {
                        const dist = this.distanceTo(other);
                        if (dist < minDistance) {
                            minDistance = dist;
                            nearest = other;
                        }
                    }
                    return nearest;
                }




                /**
                 * Calculates the distance to another entity.
                 */
                distanceTo(other) {
                    const dx = this.x - other.x;
                    const dy = this.y - other.y;
                    return Math.sqrt(dx * dx + dy * dy);
                }
                
                /**
                 * Raycasts to check for a clear line of sight to a target.
                 */
                hasLineOfSight(target) {
                    const step = 5;
                    const dx = target.x - this.x;
                    const dy = target.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > this.visionRange) {
                        return false;
                    }




                    const steps = Math.floor(distance / step);
                    const stepX = dx / steps;
                    const stepY = dy / steps;




                    for (const building of buildings) {
                        for (let i = 0; i < steps; i++) {
                            const checkX = this.x + stepX * i;
                            const checkY = this.y + stepY * i;
                            if (checkX > building.x && checkX < building.x + building.width &&
                                checkY > building.y && checkY < building.y + building.height) {
                                return false;
                            }
                        }
                    }
                    return true;
                }
            }




            /**
             * Represents a zombie.
             */
            class Zombie extends Entity {
                constructor(x, y, decayDuration) {
                    super(x, y, 6, 1.2, '#4CAF50');
                    this.type = 'zombie';
                    this.chaseSpeed = 1.2;
                    this.wanderSpeed = 0.5;
                    this.speed = this.wanderSpeed;
                    this.decayDuration = decayDuration;
                    this.decayTimer = decayDuration;
                }
                
                /**
                 * Draws the zombie with decay effect.
                 */
                draw() {
                    const decayRatio = this.decayTimer / this.decayDuration;
                    const r = 76 * decayRatio;
                    const g = 175 * decayRatio;
                    const b = 80 * decayRatio;
                    this.color = `rgb(${r}, ${g}, ${b})`;
                    super.draw();
                }




                /**
                 * Zombie's movement logic.
                 */
                move(people, police, allZombies) {
                    const targets = [...people, ...police];
                    const nearestTarget = this.findNearest(targets);
                    
                    let desiredSpeed = 0;




                    if (nearestTarget) {
                        const angle = Math.atan2(nearestTarget.y - this.y, nearestTarget.x - this.x);
                        this.dx = Math.cos(angle) * this.chaseSpeed;
                        this.dy = Math.sin(angle) * this.chaseSpeed;
                        desiredSpeed = this.chaseSpeed;
                    } else if (zombieFlockingEnabled) {
                        let cohesionVectorX = 0;
                        let cohesionVectorY = 0;
                        let cohesionCount = 0;
                        let separationVectorX = 0;
                        let separationVectorY = 0;
                        let alignmentVectorX = 0;
                        let alignmentVectorY = 0;
                        let alignmentCount = 0;




                        for (const otherZombie of allZombies) {
                            if (otherZombie === this) continue;
                            const dist = this.distanceTo(otherZombie);
                            
                            if (dist < cohesionRadius) {
                                cohesionVectorX += otherZombie.x;
                                cohesionVectorY += otherZombie.y;
                                cohesionCount++;
                            }
                            
                            if (dist < separationRadius && dist > 0) {
                                const angle = Math.atan2(this.y - otherZombie.y, this.x - otherZombie.x);
                                const force = (separationRadius - dist) / separationRadius;
                                separationVectorX += Math.cos(angle) * force;
                                separationVectorY += Math.sin(angle) * force;
                            }
                            
                            if (dist < alignmentRadius) {
                                alignmentVectorX += otherZombie.dx;
                                alignmentVectorY += otherZombie.dy;
                                alignmentCount++;
                            }
                        }




                        if (cohesionCount > 0) {
                            cohesionVectorX = (cohesionVectorX / cohesionCount) - this.x;
                            cohesionVectorY = (cohesionVectorY / cohesionCount) - this.y;
                        }




                        if (alignmentCount > 0) {
                            alignmentVectorX /= alignmentCount;
                            alignmentVectorY /= alignmentCount;
                        }
                        
                        let finalX = 0;
                        let finalY = 0;




                        const cohesionMagnitude = Math.sqrt(cohesionVectorX * cohesionVectorX + cohesionVectorY * cohesionVectorY);
                        if (cohesionMagnitude > 0) {
                            finalX += (cohesionVectorX / cohesionMagnitude) * cohesionInstinct;
                            finalY += (cohesionVectorY / cohesionMagnitude) * cohesionInstinct;
                        }




                        const separationMagnitude = Math.sqrt(separationVectorX * separationVectorX + separationVectorY * separationVectorY);
                        if (separationMagnitude > 0) {
                            finalX += (separationVectorX / separationMagnitude) * separationInstinct;
                            finalY += (separationVectorY / separationMagnitude) * separationInstinct;
                        }




                        const alignmentMagnitude = Math.sqrt(alignmentVectorX * alignmentVectorX + alignmentVectorY * alignmentVectorY);
                        if (alignmentMagnitude > 0) {
                            finalX += (alignmentVectorX / alignmentMagnitude) * alignmentInstinct;
                            finalY += (alignmentVectorY / alignmentMagnitude) * alignmentInstinct;
                        }




                        if (finalX === 0 && finalY === 0) {
                            this.dx = (Math.random() - 0.5) * this.wanderSpeed * 2;
                            this.dy = (Math.random() - 0.5) * this.wanderSpeed * 2;
                        } else {
                            const finalMagnitude = Math.sqrt(finalX * finalX + finalY * finalY);
                            if (finalMagnitude > 0) {
                                this.dx = (finalX / finalMagnitude) * this.wanderSpeed;
                                this.dy = (finalY / finalMagnitude) * this.wanderSpeed;
                            }
                        }
                        desiredSpeed = this.wanderSpeed;
                    } else {
                        this.dx = (Math.random() - 0.5) * this.wanderSpeed * 2;
                        this.dy = (Math.random() - 0.5) * this.wanderSpeed * 2;
                        desiredSpeed = this.wanderSpeed;
                    }
                    
                    const finalMagnitude = Math.sqrt(this.dx * this.dx + this.dy * this.dy);
                    if (finalMagnitude > desiredSpeed) {
                        this.dx = (this.dx / finalMagnitude) * desiredSpeed;
                        this.dy = (this.dy / finalMagnitude) * desiredSpeed;
                    }
                    
                    super.move();
                }
                
                /**
                 * Finds the nearest target (person or police) to chase.
                 */
                findNearest(targets) {
                    let nearest = null;
                    let minDistance = 150;
                    for (const target of targets) {
                        const dist = this.distanceTo(target);
                        if (dist < minDistance) {
                            minDistance = dist;
                            nearest = target;
                        }
                    }
                    return nearest;
                }
                
                /**
                 * Calculates the distance to another entity.
                 */
                distanceTo(other) {
                    const dx = this.x - other.x;
                    const dy = this.y - other.y;
                    return Math.sqrt(dx * dx + dy * dy);
                }
            }




            /**
             * Represents a fast, deadly zombie.
             */
            class RageZombie extends Entity {
                constructor(x, y, decayDuration) {
                    super(x, y, 5, 2.5, '#ff0000'); // Smaller size, faster speed, red color
                    this.type = 'rageZombie';
                    this.chaseSpeed = 2.5;
                    this.wanderSpeed = 1;
                    this.decayDuration = decayDuration;
                    this.decayTimer = decayDuration;
                }
                
                /**
                 * Draws the rage zombie with decay effect.
                 */
                draw() {
                    const decayRatio = this.decayTimer / this.decayDuration;
                    const r = 255 * decayRatio;
                    const g = 0;
                    const b = 0;
                    this.color = `rgb(${r}, ${g}, ${b})`;
                    super.draw();
                }




                move(people, police, allZombies) {
                    const targets = [...people, ...police];
                    const nearestTarget = this.findNearest(targets);
                    
                    let desiredSpeed = 0;




                    if (nearestTarget) {
                        const angle = Math.atan2(nearestTarget.y - this.y, nearestTarget.x - this.x);
                        this.dx = Math.cos(angle) * this.chaseSpeed;
                        this.dy = Math.sin(angle) * this.chaseSpeed;
                        desiredSpeed = this.chaseSpeed;
                    } else if (zombieFlockingEnabled) {
                        let cohesionVectorX = 0;
                        let cohesionVectorY = 0;
                        let cohesionCount = 0;
                        let separationVectorX = 0;
                        let separationVectorY = 0;
                        let alignmentVectorX = 0;
                        let alignmentVectorY = 0;
                        let alignmentCount = 0;




                        for (const otherZombie of allZombies) {
                            if (otherZombie === this) continue;
                            const dist = this.distanceTo(otherZombie);
                            
                            if (dist < cohesionRadius) {
                                cohesionVectorX += otherZombie.x;
                                cohesionVectorY += otherZombie.y;
                                cohesionCount++;
                            }
                            
                            if (dist < separationRadius && dist > 0) {
                                const angle = Math.atan2(this.y - otherZombie.y, this.x - otherZombie.x);
                                const force = (separationRadius - dist) / separationRadius;
                                separationVectorX += Math.cos(angle) * force;
                                separationVectorY += Math.sin(angle) * force;
                            }
                            
                            if (dist < alignmentRadius) {
                                alignmentVectorX += otherZombie.dx;
                                alignmentVectorY += otherZombie.dy;
                                alignmentCount++;
                            }
                        }




                        if (cohesionCount > 0) {
                            cohesionVectorX = (cohesionVectorX / cohesionCount) - this.x;
                            cohesionVectorY = (cohesionVectorY / cohesionCount) - this.y;
                        }




                        if (alignmentCount > 0) {
                            alignmentVectorX /= alignmentCount;
                            alignmentVectorY /= alignmentCount;
                        }
                        
                        let finalX = 0;
                        let finalY = 0;




                        const cohesionMagnitude = Math.sqrt(cohesionVectorX * cohesionVectorX + cohesionVectorY * cohesionVectorY);
                        if (cohesionMagnitude > 0) {
                            finalX += (cohesionVectorX / cohesionMagnitude) * cohesionInstinct;
                            finalY += (cohesionVectorY / cohesionMagnitude) * cohesionInstinct;
                        }




                        const separationMagnitude = Math.sqrt(separationVectorX * separationVectorX + separationVectorY * separationVectorY);
                        if (separationMagnitude > 0) {
                            finalX += (separationVectorX / separationMagnitude) * separationInstinct;
                            finalY += (separationVectorY / separationMagnitude) * separationInstinct;
                        }




                        const alignmentMagnitude = Math.sqrt(alignmentVectorX * alignmentVectorX + alignmentVectorY * alignmentVectorY);
                        if (alignmentMagnitude > 0) {
                            finalX += (alignmentVectorX / alignmentMagnitude) * alignmentInstinct;
                            finalY += (alignmentVectorY / alignmentMagnitude) * alignmentInstinct;
                        }




                        if (finalX === 0 && finalX === 0) {
                            this.dx = (Math.random() - 0.5) * this.wanderSpeed * 2;
                            this.dy = (Math.random() - 0.5) * this.wanderSpeed * 2;
                        } else {
                            const finalMagnitude = Math.sqrt(finalX * finalX + finalY * finalY);
                            if (finalMagnitude > 0) {
                                this.dx = (finalX / finalMagnitude) * this.wanderSpeed;
                                this.dy = (finalY / finalMagnitude) * this.wanderSpeed;
                            }
                        }
                        desiredSpeed = this.wanderSpeed;
                    } else {
                        this.dx = (Math.random() - 0.5) * this.wanderSpeed * 2;
                        this.dy = (Math.random() - 0.5) * this.wanderSpeed * 2;
                        desiredSpeed = this.wanderSpeed;
                    }
                    
                    const finalMagnitude = Math.sqrt(this.dx * this.dx + this.dy * this.dy);
                    if (finalMagnitude > desiredSpeed) {
                        this.dx = (this.dx / finalMagnitude) * desiredSpeed;
                        this.dy = (this.dy / finalMagnitude) * desiredSpeed;
                    }
                    
                    super.move();
                }
                
                findNearest(targets) {
                    let nearest = null;
                    let minDistance = 150;
                    for (const target of targets) {
                        const dist = this.distanceTo(target);
                        if (dist < minDistance) {
                            minDistance = dist;
                            nearest = target;
                        }
                    }
                    return nearest;
                }
                
                distanceTo(other) {
                    const dx = this.x - other.x;
                    const dy = this.y - other.y;
                    return Math.sqrt(dx * dx + dy * dy);
                }
            }




            /**
             * Represents a police officer.
             */
            class Police extends Entity {
                constructor(x, y) {
                    super(x, y, 6, 1, '#007bff');
                    this.type = 'police';
                    this.wanderSpeed = 0.5;
                    this.chaseSpeed = 1;
                    this.targetZombie = null;
                    this.shootCooldown = 30;
                    this.cooldownTimer = 0;
                    this.wanderTimer = 0;
                    this.wanderDuration = 180;
                }
                
                /**
                 * Police's movement and targeting logic.
                 */
                move(zombies, people, allPolice) {
                    const allZombies = zombies.filter(z => z.type === 'zombie' || z.type === 'rageZombie');
                    const nearbyZombies = allZombies.filter(z => this.distanceTo(z) < 200);
                    const nearbyPeople = people.filter(p => this.distanceTo(p) < 200);
                    
                    let movementVectorX = 0;
                    let movementVectorY = 0;
                    
                    if (nearbyZombies.length > 0) {
                        let nearestZombie = nearbyZombies.reduce((prev, curr) => 
                            this.distanceTo(prev) < this.distanceTo(curr) ? prev : curr);
                        this.targetZombie = nearestZombie;
                        movementVectorX = 0;
                        movementVectorY = 0;
                    } else {
                        this.targetZombie = null;
                        
                        let fleeingPeople = nearbyPeople.filter(p => p.speed > p.wanderSpeed + 0.1);
                        const peopleGroups = people.filter(p1 => 
                            people.filter(p2 => p1.distanceTo(p2) < 150).length >= 5
                        );
                        
                        if (fleeingPeople.length > 0) {
                            let centerX = fleeingPeople.reduce((sum, p) => sum + p.x, 0) / fleeingPeople.length;
                            let centerY = fleeingPeople.reduce((sum, p) => sum + p.y, 0) / fleeingPeople.length;
                            
                            const angle = Math.atan2(centerY - this.y, centerX - this.x);
                            movementVectorX = Math.cos(angle) * this.chaseSpeed;
                            movementVectorY = Math.sin(angle) * this.chaseSpeed;
                        } else if (peopleGroups.length > 0) {
                            let centerX = peopleGroups.reduce((sum, p) => sum + p.x, 0) / peopleGroups.length;
                            let centerY = peopleGroups.reduce((sum, p) => sum + p.y, 0) / peopleGroups.length;
                            
                            const angle = Math.atan2(centerY - this.y, centerX - this.x);
                            movementVectorX = Math.cos(angle) * this.chaseSpeed;
                            movementVectorY = Math.sin(angle) * this.chaseSpeed;
                        } else {
                            this.wanderTimer++;
                            if (this.wanderTimer > this.wanderDuration) {
                                movementVectorX = (Math.random() - 0.5) * this.wanderSpeed * 2;
                                movementVectorY = (Math.random() - 0.5) * this.wanderSpeed * 2;
                                this.wanderTimer = 0;
                            } else {
                                movementVectorX = this.dx;
                                movementVectorY = this.dy;
                            }
                        }
                    }


                    let separationVectorX = 0;
                    let separationVectorY = 0;
                    for (const otherPolice of allPolice) {
                        if (otherPolice === this) continue;
                        const dist = this.distanceTo(otherPolice);
                        if (dist < separationRadius && dist > 0) {
                            const angle = Math.atan2(this.y - otherPolice.y, this.x - otherPolice.x);
                            const force = (separationRadius - dist) / separationRadius;
                            separationVectorX += Math.cos(angle) * force;
                            separationVectorY += Math.sin(angle) * force;
                        }
                    }


                    const separationMagnitude = Math.sqrt(separationVectorX * separationVectorX + separationVectorY * separationVectorY);
                    if (separationMagnitude > 0) {
                        separationVectorX /= separationMagnitude;
                        separationVectorY /= separationMagnitude;
                        
                        this.dx = movementVectorX * (1 - separationInstinct) + separationVectorX * this.speed * separationInstinct;
                        this.dy = movementVectorY * (1 - separationInstinct) + separationVectorY * this.speed * separationInstinct;
                        
                        const finalMagnitude = Math.sqrt(this.dx * this.dx + this.dy * this.dy);
                        if (finalMagnitude > this.speed) {
                            this.dx = (this.dx / finalMagnitude) * this.speed;
                            this.dy = (this.dy / finalMagnitude) * this.speed;
                        }
                    } else {
                        this.dx = movementVectorX;
                        this.dy = movementVectorY;
                    }
                    
                    this.speed = Math.sqrt(this.dx*this.dx + this.dy*this.dy);
                    super.move();
                }




                /**
                 * Shoots a spread of particles at a target.
                 */
                shoot() {
                    if (this.targetZombie && this.cooldownTimer <= 0) {
                        const angleToTarget = Math.atan2(this.targetZombie.y - this.y, this.targetZombie.x - this.x);
                        const spreadAngle = 0.5;
                        const numParticles = 5;
                        
                        for (let i = 0; i < numParticles; i++) {
                            const offset = (Math.random() - 0.5) * spreadAngle;
                            const particleAngle = angleToTarget + offset;
                            
                            const particleSpeed = 5;
                            const dx = Math.cos(particleAngle) * particleSpeed;
                            const dy = Math.sin(particleAngle) * particleSpeed;
                            
                            particles.push(new Particle(this.x, this.y, dx, dy));
                        }
                        this.cooldownTimer = (120 - policeFireRate) + 10;
                    }
                    if (this.cooldownTimer > 0) {
                        this.cooldownTimer--;
                    }
                }




                /**
                 * Calculates the distance to another entity.
                 */
                distanceTo(other) {
                    const dx = this.x - other.x;
                    const dy = this.y - other.y;
                    return Math.sqrt(dx * dx + dy * dy);
                }
            }
            
            /**
             * Represents a supply item.
             */
            class Supply {
                constructor(x, y) {
                    this.x = x;
                    this.y = y;
                    this.size = 10;
                    this.color = '#ffff00';
                }
                
                draw() {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y - this.size);
                    ctx.lineTo(this.x - this.size, this.y + this.size);
                    ctx.lineTo(this.x + this.size, this.y + this.size);
                    ctx.closePath();
                    ctx.fill();
                }
            }




            /**
             * Represents a particle projectile fired by police.
             */
            class Particle {
                constructor(x, y, dx, dy) {
                    this.x = x;
                    this.y = y;
                    this.size = 2;
                    this.dx = dx;
                    this.dy = dy;
                    this.color = '#87ceeb';
                    this.lifetime = 120;
                }




                draw() {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                }




                update() {
                    this.x += this.dx;
                    this.y += this.dy;
                    this.lifetime--;
                }
            }




            // --- SIMULATION FUNCTIONS ---




            /**
             * Displays a custom message box.
             */
            window.showMessage = function(message) {
                messageText.textContent = message;
                overlay.style.display = 'block';
                messageBox.style.display = 'flex';
                stopSimulation();
            }




            /**
             * Closes the custom message box.
             */
            window.closeMessage = function() {
                overlay.style.display = 'none';
                messageBox.style.display = 'none';
            }
            
            /**
             * Toggles between Sim and Idle modes and resets the simulation.
             */
            function toggleMode() {
                isIdleMode = !isIdleMode;
                modeDisplay.textContent = `Mode: ${isIdleMode ? 'Idle' : 'Sim'}`;
                initializeSimulation();
            }




            /**
             * Creates a single building with a specific color and size range.
             */
            function createEmitter(color, minSize = 80, maxSize = 150) {
                let newBuilding;
                let isColliding = true;
                let attempts = 0;




                while (isColliding && attempts < 50) {
                    const width = Math.random() * (maxSize - minSize) + minSize;
                    const height = Math.random() * (maxSize - minSize) + minSize;
                    const x = Math.random() * (currentMapSize - width);
                    const y = Math.random() * (currentMapSize - height);
                    newBuilding = { x, y, width, height, color };




                    isColliding = false;
                    for (const existingBuilding of buildings) {
                        if (isRectCollision(newBuilding, existingBuilding)) {
                            isColliding = true;
                            break;
                        }
                    }
                    attempts++;
                }




                if (!isColliding) {
                    buildings.push(newBuilding);
                    return newBuilding; // Return the new building for assignment
                }
                return null;
            }
            
            /**
             * Generates a single building, ensuring it doesn't overlap with existing ones.
             */
            function createBuilding() {
                const minSize = 20; // Buildings are now smaller
                const maxSize = 80;
                let newBuilding;
                let isColliding = true;
                let attempts = 0;




                while (isColliding && attempts < 50) {
                    const width = Math.random() * (maxSize - minSize) + minSize;
                    const height = Math.random() * (maxSize - minSize) + minSize;
                    const x = Math.random() * (currentMapSize - width);
                    const y = Math.random() * (currentMapSize - height);
                    newBuilding = { x, y, width, height, color: '#444' };




                    isColliding = false;
                    for (const existingBuilding of buildings) {
                        if (isRectCollision(newBuilding, existingBuilding)) {
                            isColliding = true;
                            break;
                        }
                    }
                    attempts++;
                }




                if (!isColliding) {
                    buildings.push(newBuilding);
                }
            }




            /**
             * Checks for collision between two rectangles.
             */
            function isRectCollision(rect1, rect2) {
                return rect1.x < rect2.x + rect2.width &&
                       rect1.x + rect1.width > rect2.x &&
                       rect1.y < rect2.y + rect2.height &&
                       rect1.y + rect1.height > rect2.y;
            }




            /**
             * Initializes the simulation with a fresh state.
             */
            function initializeSimulation() {
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                }
                isRunning = false;




                // Update canvas dimensions based on new map size
                currentMapSize = parseFloat(mapSizeInput.value);
                canvas.width = currentMapSize;
                canvas.height = currentMapSize;




                // Update simulation parameters from sliders
                cohesionRadius = parseFloat(cohesionRadiusInput.value);
                cohesionInstinct = parseFloat(cohesionInstinctInput.value);
                separationRadius = parseFloat(separationRadiusInput.value);
                separationInstinct = parseFloat(separationInstinctInput.value);
                alignmentRadius = parseFloat(alignmentRadiusInput.value);
                alignmentInstinct = parseFloat(alignmentInstinctInput.value);
                policeFireRate = parseFloat(policeFireRateInput.value);
                policeImmunityEnabled = policeImmunityToggle.checked;
                peopleFlockingEnabled = peopleFlockingToggle.checked;
                zombieFlockingEnabled = zombieFlockingToggle.checked;
                buildingDensity = parseFloat(buildingDensityInput.value);
                humanSpawnRate = parseFloat(humanSpawnRateInput.value);
                zombieSpawnRate = parseFloat(zombieSpawnRateInput.value);
                rageZombieSpawnRate = parseFloat(rageZombieSpawnRateInput.value);
                policeSpawnRate = parseFloat(policeSpawnRateInput.value);
                zombieDecayDuration = parseFloat(zombieDecayDurationInput.value);
                supplySpawnRate = parseFloat(supplySpawnRateInput.value);








                entities = [];
                buildings = [];
                supplies = [];
                particles = [];
                suppliesCollectedCount = 0;
                
                let zombieCount, rageZombieCount, personCount, policeCount;
                humanEmitter = null;
                zombieEmitter = null;
                rageZombieEmitter = null; 
                policeEmitter = null;
                humanSpawnTimer = 0;
                zombieSpawnTimer = 0;
                rageZombieSpawnTimer = 0;
                policeSpawnTimer = 0;


                modeDisplay.textContent = `Mode: ${isIdleMode ? 'Idle' : 'Sim'}`;




                if (isIdleMode) {
                    // Idle Mode: Initial counts are zero.
                    zombieCount = 0;
                    rageZombieCount = 0;
                    personCount = 0;
                    policeCount = 0;
                    
                    // Spawn special emitter buildings
                    humanEmitter = createEmitter('#cccccc', 80, 150); 
                    zombieEmitter = createEmitter('#4CAF50', 80, 150); 
                    rageZombieEmitter = createEmitter('#ff0000', 50, 80); 
                    policeEmitter = createEmitter('#007bff', 60, 100);
                    
                } else {
                    // Sim Mode: Use the input values.
                    zombieCount = parseInt(zombieCountInput.value, 10);
                    rageZombieCount = parseInt(rageZombieCountInput.value, 10);
                    personCount = parseInt(personCountInput.value, 10);
                    policeCount = parseInt(policeCountInput.value, 10);
                    
                    // Generate buildings based on density for Sim Mode
                    const numBuildings = Math.floor((currentMapSize / 100) * (buildingDensity / 20) + 2);
                    for (let i = 0; i < numBuildings; i++) {
                        createBuilding();
                    }
                }




                personCountDisplay.textContent = personCount;
                zombieCountDisplay.textContent = zombieCount;
                rageZombieCountDisplay.textContent = rageZombieCount;
                policeCountDisplay.textContent = policeCount;
                suppliesCollectedDisplay.textContent = suppliesCollectedCount;




                const totalEntities = zombieCount + rageZombieCount + personCount + policeCount;
                for (let i = 0; i < totalEntities; i++) {
                    let x, y;
                    let isInBuilding = true;
                    let attempts = 0;
                    const spawnPadding = 10; // Extra padding to avoid spawning too close




                    while (isInBuilding && attempts < 100) {
                        x = Math.random() * currentMapSize;
                        y = Math.random() * currentMapSize;
                        isInBuilding = false;
                        for (const building of buildings) {
                            if (x > building.x - spawnPadding && x < building.x + building.width + spawnPadding &&
                                y > building.y - spawnPadding && y < building.y + building.height + spawnPadding) {
                                isInBuilding = true;
                                break;
                            }
                        }
                        attempts++;
                    }




                    if (isInBuilding) {
                        // If we can't find a spot after 100 attempts, skip this entity.
                        continue;
                    }




                    let newEntity;
                    if (i < zombieCount) {
                        newEntity = new Zombie(x, y, zombieDecayDuration);
                    } else if (i < zombieCount + rageZombieCount) {
                        newEntity = new RageZombie(x, y, zombieDecayDuration);
                    } else if (i < zombieCount + rageZombieCount + personCount) {
                        newEntity = new Person(x, y);
                    } else {
                        newEntity = new Police(x, y);
                    }
                    entities.push(newEntity);
                }




                draw();
                startBtn.textContent = 'Start Simulation';
            }




            /**
             * The main drawing function.
             */
            function draw() {
                ctx.clearRect(0, 0, currentMapSize, currentMapSize);




                buildings.forEach(building => {
                    ctx.fillStyle = building.color;
                    ctx.fillRect(building.x, building.y, building.width, building.height);
                });




                entities.forEach(entity => entity.draw());
                particles.forEach(particle => particle.draw());
                supplies.forEach(supply => supply.draw());
            }




            /**
             * The main update function for the simulation logic.
             */
            function update() {
                const zombies = entities.filter(e => e.type === 'zombie');
                const rageZombies = entities.filter(e => e.type === 'rageZombie');
                const people = entities.filter(e => e.type === 'person');
                const police = entities.filter(e => e.type === 'police');
                let newEntities = [...entities];
                const frameTime = 1000 / 60; // Assuming 60 FPS
                
                personCountDisplay.textContent = people.length;
                zombieCountDisplay.textContent = zombies.length;
                rageZombieCountDisplay.textContent = rageZombies.length;
                policeCountDisplay.textContent = police.length;
                suppliesCollectedDisplay.textContent = suppliesCollectedCount;
                
                // --- IDLE GAME LOGIC: SPAWN ENTITIES FROM EMITTERS ---
                if (isIdleMode) {
                    // Human Emitter Logic
                    humanSpawnTimer += frameTime;
                    if (humanSpawnTimer >= humanSpawnRate) {
                        if (humanEmitter) {
                            const angle = Math.random() * Math.PI * 2;
                            const radius = Math.max(humanEmitter.width, humanEmitter.height) / 2 + 10;
                            const x = humanEmitter.x + humanEmitter.width / 2 + Math.cos(angle) * radius;
                            const y = humanEmitter.y + humanEmitter.height / 2 + Math.sin(angle) * radius;
                            newEntities.push(new Person(x, y));
                        }
                        humanSpawnTimer = 0;
                    }




                    // Zombie Emitter Logic
                    zombieSpawnTimer += frameTime;
                    if (zombieSpawnTimer >= zombieSpawnRate) {
                        if (zombieEmitter) {
                            const angle = Math.random() * Math.PI * 2;
                            const radius = Math.max(zombieEmitter.width, zombieEmitter.height) / 2 + 10;
                            const x = zombieEmitter.x + zombieEmitter.width / 2 + Math.cos(angle) * radius;
                            const y = zombieEmitter.y + zombieEmitter.height / 2 + Math.sin(angle) * radius;
                            newEntities.push(new Zombie(x, y, zombieDecayDuration));
                        }
                        zombieSpawnTimer = 0;
                    }
                    
                    // Rage Zombie Emitter Logic
                    rageZombieSpawnTimer += frameTime;
                    if (rageZombieSpawnTimer >= rageZombieSpawnRate) {
                        if (rageZombieEmitter) {
                            const angle = Math.random() * Math.PI * 2;
                            const radius = Math.max(rageZombieEmitter.width, rageZombieEmitter.height) / 2 + 10;
                            const x = rageZombieEmitter.x + rageZombieEmitter.width / 2 + Math.cos(angle) * radius;
                            const y = rageZombieEmitter.y + rageZombieEmitter.height / 2 + Math.sin(angle) * radius;
                            newEntities.push(new RageZombie(x, y, zombieDecayDuration));
                        }
                        rageZombieSpawnTimer = 0;
                    }


                    // Police Emitter Logic
                    policeSpawnTimer += frameTime;
                    if (policeSpawnTimer >= policeSpawnRate) {
                        if (policeEmitter) {
                            const angle = Math.random() * Math.PI * 2;
                            const radius = Math.max(policeEmitter.width, policeEmitter.height) / 2 + 10;
                            const x = policeEmitter.x + policeEmitter.width / 2 + Math.cos(angle) * radius;
                            const y = policeEmitter.y + policeEmitter.height / 2 + Math.sin(angle) * radius;
                            newEntities.push(new Police(x, y));
                        }
                        policeSpawnTimer = 0;
                    }
                }
                
                // Supply Spawning Logic
                supplySpawnTimer += frameTime; 
                if (supplySpawnTimer >= supplySpawnRate) {
                    let newSupply;
                    let isColliding = true;
                    let attempts = 0;
                    
                    // Find a random, clear spot to spawn the supply
                    while (isColliding && attempts < 50) {
                        const x = Math.random() * currentMapSize;
                        const y = Math.random() * currentMapSize;
                        newSupply = new Supply(x, y);




                        isColliding = false;
                        for (const building of buildings) {
                            if (x > building.x && x < building.x + building.width &&
                                y > building.y && y < building.y + building.height) {
                                isColliding = true;
                                break;
                            }
                        }
                        attempts++;
                    }




                    if (!isColliding) {
                        supplies.push(newSupply);
                    }
                    supplySpawnTimer = 0;
                }




                // Zombie Decay Logic
                for (let i = entities.length - 1; i >= 0; i--) {
                    const entity = entities[i];
                    if (entity.type === 'zombie' || entity.type === 'rageZombie') {
                        entity.decayTimer--;
                        if (entity.decayTimer <= 0) {
                            entities.splice(i, 1);
                        }
                    }
                }
                
                entities.forEach(entity => {
                    if (entity.type === 'zombie' || entity.type === 'rageZombie') {
                        entity.move(people, police, [...zombies, ...rageZombies]);
                    } else if (entity.type === 'person') {
                        entity.move([...zombies, ...rageZombies], people, supplies, humanEmitter);
                    } else if (entity.type === 'police') {
                        entity.move([...zombies, ...rageZombies], people, police);
                        entity.shoot();
                    }
                });


                // Despawn entities that clip into buildings
                for (let i = newEntities.length - 1; i >= 0; i--) {
                    const entity = newEntities[i];
                    let clipped = false;
                    for (const building of buildings) {
                        if (entity.x > building.x && entity.x < building.x + building.width &&
                            entity.y > building.y && entity.y < building.y + building.height) {
                            clipped = true;
                            break; 
                        }
                    }
                    if (clipped) {
                        newEntities.splice(i, 1);
                    }
                }


                // Supply Collection Logic - now handles the full collection flow for Idle Mode // #supplylogic
                for (let i = people.length - 1; i >= 0; i--) {
                    const person = people[i];
                    
                    // Check if person picks up a supply
                    if (person.state === 'seeking_supply' && person.targetSupply) { // #supplylogic
                        const distance = person.distanceTo(person.targetSupply); // #supplylogic
                        if (distance < person.size + person.targetSupply.size) { // #supplylogic
                             if (isIdleMode) { // #supplylogic
                                supplies = supplies.filter(s => s !== person.targetSupply); // #supplylogic
                                person.targetSupply = null; // #supplylogic
                                person.state = 'returning_to_base'; // #supplylogic
                                person.hasSupply = true; // #supplylogic Person is now carrying a supply
                            } else {
                                // Original Sim mode logic
                                supplies = supplies.filter(s => s !== person.targetSupply); // #supplylogic
                                person.targetSupply = null; // #supplylogic
                                suppliesCollectedCount++; // #supplylogic
                                person.state = 'wander'; // #supplylogic
                            }
                        }
                    }




                    // Check if person returns to base with a supply (Idle Mode only) // #supplylogic
                    if (isIdleMode && person.hasSupply && humanEmitter) { // #supplylogic
                        const padding = 5; // #supplylogic Generous padding for the hitbox
                        const emitterHitbox = { // #supplylogic Define the rectangular hitbox
                            x: humanEmitter.x - padding,
                            y: humanEmitter.y - padding,
                            width: humanEmitter.width + padding * 2,
                            height: humanEmitter.height + padding * 2
                        };
                        
                        // #supplylogic Check for collision with the rectangular hitbox
                        if (person.x > emitterHitbox.x &&
                            person.x < emitterHitbox.x + emitterHitbox.width &&
                            person.y > emitterHitbox.y &&
                            person.y < emitterHitbox.y + emitterHitbox.height) 
                        {
                            suppliesCollectedCount++; // #supplylogic Increment counter on return
                            newEntities = newEntities.filter(e => e !== person); // #supplylogic Despawn the person
                        }
                    }
                }




                particles = particles.filter(p => p.lifetime > 0);
                
                for (let i = particles.length - 1; i >= 0; i--) {
                    const particle = particles[i];
                    let hitBuilding = false;
                    for (const building of buildings) {
                        if (particle.x > building.x && particle.x < building.x + building.width &&
                            particle.y > building.y && particle.y < building.y + building.height) {
                            particles.splice(i, 1);
                            hitBuilding = true;
                            break;
                        }
                    }
                    if (!hitBuilding) {
                        particle.update();
                    }
                }
                
                const infectedThisFrame = [];
                const destroyedThisFrame = [];




                // Regular zombie interactions
                for (const zombie of zombies) {
                    for (const person of people) {
                        const distance = Math.sqrt(Math.pow(zombie.x - person.x, 2) + Math.pow(zombie.y - person.y, 2));
                        if (distance < zombie.size + person.size) {
                            infectedThisFrame.push(new Zombie(person.x, person.y, zombieDecayDuration));
                            newEntities = newEntities.filter(e => e !== person);
                        }
                    }
                    if (!policeImmunityEnabled) {
                        for (const cop of police) {
                            const distance = Math.sqrt(Math.pow(zombie.x - cop.x, 2) + Math.pow(zombie.y - cop.y, 2));
                            if (distance < zombie.size + cop.size) {
                                infectedThisFrame.push(new Zombie(cop.x, cop.y, zombieDecayDuration));
                                newEntities = newEntities.filter(e => e !== cop);
                            }
                        }
                    }
                }
                
                // Rage zombie interactions
                for (const rageZombie of rageZombies) {
                    for (const person of people) {
                        const distance = Math.sqrt(Math.pow(rageZombie.x - person.x, 2) + Math.pow(rageZombie.y - person.y, 2));
                        if (distance < rageZombie.size + person.size) {
                            if (Math.random() < 0.5) { // 50% chance to kill
                                newEntities = newEntities.filter(e => e !== person);
                            } else { // 50% chance to turn
                                infectedThisFrame.push(new Zombie(person.x, person.y, zombieDecayDuration));
                                newEntities = newEntities.filter(e => e !== person);
                            }
                        }
                    }
                    for (const cop of police) {
                        const distance = Math.sqrt(Math.pow(rageZombie.x - cop.x, 2) + Math.pow(rageZombie.y - cop.y, 2));
                        if (distance < rageZombie.size + cop.size) {
                            // Always kill police regardless of immunity toggle
                            newEntities = newEntities.filter(e => e !== cop);
                        }
                    }
                }




                // Bullet collisions with all zombies
                for (let i = 0; i < particles.length; i++) {
                    const particle = particles[i];
                    for (const zombie of zombies) {
                        const distance = Math.sqrt(Math.pow(zombie.x - particle.x, 2) + Math.pow(zombie.y - particle.y, 2));
                        if (distance < zombie.size + particle.size) {
                            if (!destroyedThisFrame.includes(zombie)) {
                                destroyedThisFrame.push(zombie);
                                newEntities = newEntities.filter(e => e !== zombie);
                            }
                            particles.splice(i, 1);
                            i--;
                            break;
                        }
                    }
                    for (const rageZombie of rageZombies) {
                        const distance = Math.sqrt(Math.pow(rageZombie.x - particle.x, 2) + Math.pow(rageZombie.y - particle.y, 2));
                        if (distance < rageZombie.size + particle.size) {
                            if (!destroyedThisFrame.includes(rageZombie)) {
                                destroyedThisFrame.push(rageZombie);
                                newEntities = newEntities.filter(e => e !== rageZombie);
                            }
                            particles.splice(i, 1);
                            i--;
                            break;
                        }
                    }
                }




                entities = [...newEntities, ...infectedThisFrame];




                if (!isIdleMode && isRunning) {
                    if (people.length === 0 && police.length === 0) {
                        showMessage('The zombies have won! No people or police left.');
                    } else if (zombies.length === 0 && rageZombies.length === 0) {
                        showMessage('The people and police have won! No zombies left.');
                    }
                }
            }




            /**
             * The main game loop.
             */
            function gameLoop() {
                update();
                draw();
                animationFrameId = requestAnimationFrame(gameLoop);
            }




            /**
             * Starts the simulation.
             */
            function startSimulation() {
                if (!isRunning) {
                    gameLoop();
                    isRunning = true;
                    startBtn.textContent = 'Running...';
                }
            }




            /**
             * Stops the simulation.
             */
            function stopSimulation() {
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }
                isRunning = false;
                startBtn.textContent = 'Start Simulation';
            }
            
            // --- EVENT LISTENERS FOR CONTROLS ---
            cohesionRadiusInput.addEventListener('input', () => {
                cohesionRadius = parseFloat(cohesionRadiusInput.value);
            });
            cohesionInstinctInput.addEventListener('input', () => {
                cohesionInstinct = parseFloat(cohesionInstinctInput.value);
            });
            separationRadiusInput.addEventListener('input', () => {
                separationRadius = parseFloat(separationRadiusInput.value);
            });
            separationInstinctInput.addEventListener('input', () => {
                separationInstinct = parseFloat(separationInstinctInput.value);
            });
            alignmentRadiusInput.addEventListener('input', () => {
                alignmentRadius = parseFloat(alignmentRadiusInput.value);
            });
            alignmentInstinctInput.addEventListener('input', () => {
                alignmentInstinct = parseFloat(alignmentInstinctInput.value);
            });
            policeFireRateInput.addEventListener('input', () => {
                policeFireRate = parseFloat(policeFireRateInput.value);
            });
            policeImmunityToggle.addEventListener('change', (e) => {
                policeImmunityEnabled = e.target.checked;
            });
            peopleFlockingToggle.addEventListener('change', (e) => {
                peopleFlockingEnabled = e.target.checked;
            });
            zombieFlockingToggle.addEventListener('change', (e) => {
                zombieFlockingEnabled = e.target.checked;
            });
            mapSizeInput.addEventListener('input', (e) => {
                currentMapSize = parseFloat(e.target.value);
                mapSizeValueDisplay.textContent = currentMapSize;
                canvas.width = currentMapSize;
                canvas.height = currentMapSize;
                // Re-initialize to respawn entities and buildings on the new map size
                if (isRunning) {
                    stopSimulation();
                    initializeSimulation();
                    startSimulation();
                } else {
                    initializeSimulation();
                }
            });
            buildingDensityInput.addEventListener('input', (e) => {
                buildingDensity = parseFloat(e.target.value);
                buildingDensityValueDisplay.textContent = buildingDensity;
                if (isRunning) {
                    stopSimulation();
                    initializeSimulation();
                    startSimulation();
                } else {
                    initializeSimulation();
                }
            });
            humanSpawnRateInput.addEventListener('input', (e) => {
                humanSpawnRate = parseFloat(e.target.value);
                humanSpawnRateValueDisplay.textContent = humanSpawnRate + 'ms';
            });
            zombieSpawnRateInput.addEventListener('input', (e) => {
                zombieSpawnRate = parseFloat(e.target.value);
                zombieSpawnRateValueDisplay.textContent = zombieSpawnRate + 'ms';
            });
            rageZombieSpawnRateInput.addEventListener('input', (e) => {
                rageZombieSpawnRate = parseFloat(e.target.value);
                rageZombieSpawnRateValueDisplay.textContent = rageZombieSpawnRate + 'ms';
            });
            policeSpawnRateInput.addEventListener('input', (e) => {
                policeSpawnRate = parseFloat(e.target.value);
                policeSpawnRateValueDisplay.textContent = policeSpawnRate + 'ms';
            });
            zombieDecayDurationInput.addEventListener('input', (e) => {
                zombieDecayDuration = parseFloat(e.target.value);
                zombieDecayDurationValueDisplay.textContent = zombieDecayDuration;
            });
            supplySpawnRateInput.addEventListener('input', (e) => {
                supplySpawnRate = parseFloat(e.target.value);
                supplySpawnRateValueDisplay.textContent = supplySpawnRate;
            });




            // Add event listeners for collapsible headers
            collapsibleHeaders.forEach(header => {
                header.addEventListener('click', () => {
                    const parentPanel = header.parentElement;
                    parentPanel.classList.toggle('collapsed');
                });
            });




            // --- EVENT LISTENERS ---
            startBtn.addEventListener('click', startSimulation);
            resetBtn.addEventListener('click', initializeSimulation);
            toggleModeBtn.addEventListener('click', toggleMode);




            // Initial setup
            initializeSimulation();
        };
    </script>
</body>
</html>